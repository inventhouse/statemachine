#!/usr/bin/env python3
# Copyright (c) 2019 Benjamin Holt -- MIT License

"""
Statemachine Line EDitor
or: Sed-Like EDitor

Like `sed` but using statemachine-based rules instead of imperative commands.
"""
import argparse
import re
import textwrap

import statemachine as sm
#####


###  Main  ###
def main(args, env, stdin):
    description = "Statemachine Line EDitor, like `sed` but built with statemachine rules (v0.9)"
    epilog = textwrap.dedent("""\
    Rules can be created with -r/--named-rules and start with a delimiter character of our choice follwed by 7 fields:

        :name:test:arg:dst:action:arg:tag

    Rules are added to states in the underlying statemachine with -a/--add-rules, and may be either named or anonymous:

        :state:name:tag
        :state:test:arg:dst:action:arg:tag

    Unnecessary fields may be omitted from the end in all cases, and 'test' and 'action' commands are not case-sensitive.  Rules with no 'state' specified are implicitly added to all states, but evaluated after any explicit rules; rules with no 'dst' remain in the same state ("self-transition")

    More documentation and examples in sled.md:
    https://github.com/inventhouse/statemachine/blob/master/sled.md
    """)

    arg_parser = argparse.ArgumentParser(
        description=wrapper(description, width=75),
        epilog=wrapper(epilog, width=75),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    # arg_parser.add_argument(
    #     "in_file",
    #     nargs="?",
    #     metavar="FILE",
    #     help="File to parse, defaults to stdin.",
    # )
    arg_parser.add_argument(
        "-s", "--start",
        default="start",
        metavar="STATE",
        help="Start the parser in STATE, defaults to 'start'.",
    )
    arg_parser.add_argument(
        "-r", "--named-rules",
        nargs="+",
        default=[],
        metavar="RULE",
        help="Define named rules to be added to states below",
    )
    arg_parser.add_argument(
        "-a", "--add-rules",
        nargs="+",
        default=[],
        metavar="RULE",
        help="Add rules to the statemachine.",
    )
    # arg_parser.add_argument(
    #     "-f", "--rules-file",
    #     metavar="FILE",
    #     help="A file of rules for the statemachine.",
    # )
    arg_parser.add_argument(
        "-d", "--drop-all",
        dest="default_rule",
        action="store_const",
        const=(None, sm.trueTest, None, None, "DropAll"),
        default=None,
        help="Add a final DropAll rule to drop any input not handled."
    )
    arg_parser.add_argument(
        "-p", "--pass-all",
        dest="default_rule",
        action="store_const",
        const=(None, sm.trueTest, None, sm.inputAction, "PassAll"),
        default=None,
        help="Add a final PassAll rule to pass any input not handled."
    )
    arg_parser.add_argument(
        "-t", "--trace",
        nargs="?",
        default=None,
        const="T> ",
        metavar="N|PREFIX",
        help="An integer will set the default tracing depth, negative means unlimited.  Otherwise, add a verbose trace to the statemachine; trace lines will start with PREFIX, by default 'T> '.",
    )
    arg_parser.add_argument(
        "--more-help",
        action="store_true",
        help="Print help about the available tests and actions.",
    )
    arg_parser.add_argument(
        "--print-args",
        action="store_true",
        # help="Print arguments and compiled rules, then exit.",
        help=argparse.SUPPRESS,
    )
    my_args = arg_parser.parse_args(args[1:])

    named_rules = { n: r for n,*r in parse_rules(my_args.named_rules) }
    rules = parse_rules(my_args.add_rules, aliases=named_rules)
    if my_args.default_rule:
        rules.append(my_args.default_rule)

    if my_args.print_args:
        print(f"* Args:\n\t{my_args}\n* Named Rules:\n\t{named_rules}\n* Rules:\n\t{rules}")
        return 0
    if my_args.more_help:
        print(f"{helper(Tests)}\n\n{helper(Actions)}")
        return 0

    tracer = True  # Use the built-in default tracing
    if my_args.trace:
        try:
            # If int, set trace depth
            tracer = int(my_args.trace)
        except ValueError:
            # Add additional verbose tracing
            tracer = sm.Tracer(printer=lambda s: print(f"{my_args.trace}{s}"))
    parser = sm.StateMachine(my_args.start, tracer=tracer)
    for r in rules:
        parser.add(*r)

    for line in parser.parse( l.rstrip("\n") for l in stdin ):
        print(line)
#####


###  Rule Parsing  ###
def parse_rules(l, aliases=None):
    "Parse a list of rule strings into rules suitable for statemachine.add"
    rules = []
    for s in l:
        parts = split_rule(s)

        if aliases and len(parts) <= 3:
            # Very short rule may be an alias reference
            parts += [None,] * 3
            if parts[1] in aliases:
                r = [parts[0], *aliases[parts[1]]]
                if parts[2]:
                    # Override the tag if one was specified
                    r[-1] = parts[2]
                elif not r[-1]:
                    # Auto-tag with rule name if none was specified
                    r[-1] = parts[1]
                rules.append(r)
                continue

        parts += [None,] * 7
        (name, test, t_arg, dst, action, a_arg, tag) = parts[:7]

        if not test:
            test = "_default"
        l_test = test.lower()
        if l_test not in Tests.__dict__:
            raise KeyError(f"no '{test}' in Tests, run with --more-help for full list")
        test = Tests.__dict__[l_test](t_arg)

        if not action:
            action = "_default"
        l_action = action.lower()
        if l_action not in Actions.__dict__:
            raise KeyError(f"no '{action}' in Actions, run with --more-help for full list")
        action = Actions.__dict__[l_action](a_arg)

        rules.append((name, test, dst, action, tag))
    return rules


def split_rule(s):
    "Split a rule string based on the inital delimeter"
    d,s = s[0], s[1:]
    parts = [ p if len(p) else None for p in s.split(d) ]
    return parts


class Tests:
    "Tests"
    def t(_):
        ":T::\talways True"
        return sm.trueTest

    def l(s):
        ":L:s:\tLiteral string, no string matches empty line"
        # None isn't a thing we'll find in the input lines, test for empty string instead
        return s if s else ""

    def m(s):
        ":M:p:\tMatch a regex pattern"
        return sm.matchTest(s)

    def s(s):
        ":S:p:\tSearch for a regex pattern"
        r = re.compile(s)
        def c(i, _):
            return r.search(i)
        return c

    def ceq(n):
        ":CEQ:n:\tinput Count EQuals"
        n = int(n)
        return lambda i, t: t.count == n

    def cgt(n):
        ":CGT:n:\tinput Count Greater-Than"
        n = int(n)
        return lambda i, t: t.count > n

    def clt(n):
        ":CLT:n:\tinput Count Less-Than"
        n = int(n)
        return lambda i, t: t.count < n

    def _default(s):
        "::s:\tdefault test is 'L'"
        return Tests.L(s)


class Actions:
    "Actions"
    def f(s):
        ":F:s:\tFormatted output; input will be passed as 'i', test result will be 'r'"
        return lambda i, t: s.format(i=i, r=t.result)

    def i(_):
        ":I::\treturn the Input"
        return sm.inputAction

    def l(s):
        ":L:s:\tLiteral string"
        # Return empty string instead of None
        return s if s else ""

    def s(s):
        ":S:r:\tSub all occurrences of the test pattern with a replacement"
        # TODO: assert the result is an re.match
        return lambda i, t: t.result.re.sub(s, i)

    def _default(s):
        ":::\tdefault action returns no output (drops input)"
        return None
#####


###  Helpers  ###
def wrapper(text, **kwargs):
    "Nothing worse than a bad wrap"
    # Wrap each paragraph separately, then put them back together
    return "\n".join([ textwrap.fill(s, **kwargs) for s in text.splitlines() ])


def helper(cls):
    "Extract doc strings from a class's 'regular' methods to build a help-string"
    keys = sorted([ k for k in cls.__dict__.keys() if not k.startswith("_") ])
    helps = [ (k, cls.__dict__[k].__doc__) for k in keys if cls.__dict__[k].__doc__ ]
    default_key = "_default"
    if default_key in cls.__dict__ and cls.__dict__[default_key].__doc__:
        helps.append(("None", cls.__dict__[default_key].__doc__))
    # help_string = "\n\t".join([ f"{k}:\t{h}" for k,h in helps ])
    help_string = "\n\t".join([ f"{h}" for _,h in helps ])
    return f"{cls.__doc__}:\n\t{help_string}"
#####


#####
if __name__ == "__main__":
    import os
    import sys
    xit = main(sys.argv, os.environ, sys.stdin)
    sys.exit(xit)
#####
