#!/usr/bin/env python3
# Copyright (c) 2019 Benjamin Holt -- MIT License

"""
Statemachine Line EDitor
or: Sed-Like EDitor

Like `sed` but using consistent statemachine-based rules instead of ad-hoc; maybe with some backwards-compatible(ish) conveniences, though
"""
import argparse
import re

import statemachine as sm
#####


###  Main  ###
def main(args, env, stdin):
    epilog = "Statemachine Line EDitor, like `sed` but built with statemachine rules (v0.1)"
    arg_parser = argparse.ArgumentParser(epilog=epilog)
    # arg_parser.add_argument(
    #     "in_file",
    #     nargs="?",
    #     metavar="FILE",
    #     help="File to parse, defaults to stdin.",
    # )
    arg_parser.add_argument(
        "-s", "--start",
        default="start",
        metavar="STATE",
        help="Start the parser in STATE, defaults to 'start'.",
    )
    arg_parser.add_argument(
        "-a", "--add-rules",
        nargs="+",
        default=[],
        # action="append",
        metavar="RULE",
        help="Adds a rule to the statemachine.",
    )
    # arg_parser.add_argument(
    #     "-b", "--buckets",
    #     nargs="+",
    #     type=int,
    #     metavar="X",
    #     help="Buckets to make names for, default is all buckets.",
    # )
    # arg_parser.add_argument(
    #     "-c", "--check-only",
    #     action="store_true",
    #     help="Just check what bucket the user is in, don't generate names.",
    # )
    arg_parser.add_argument(
        "--more-help",
        action="store_true",
        help="Print help about the available tests and actions.",
    )
    arg_parser.add_argument(
        "--print-args",
        action="store_true",
        # help="Print arguments and compiled rules, then exit.",
        help=argparse.SUPPRESS,
    )
    my_args = arg_parser.parse_args(args[1:])
    rules = parse_rules(my_args.add_rules)
    if my_args.print_args:
        print(f"* Args:\n\t{my_args}\n* Rules:\n\t{rules}")
        return 0
    if my_args.more_help:
        print(f"{TESTS.help()}\n\n{ACTIONS.help()}")
        return 0

    parser = sm.StateMachine(my_args.start)
    for r in rules:
        parser.add(*r)

    for line in parser.parse(l.rstrip("\n") for l in stdin):
        print(line)
#####


###  Rule Parsing  ###
def parse_rules(l):
    rules = []
    for s in l:
        (name, test, t_arg, dst, action, a_arg, tag) = split_rule(s)
        test = TESTS.lookup(test, t_arg)
        action = ACTIONS.lookup(action, a_arg)
        rules.append((name, test, dst, action, tag))
    return rules


def split_rule(s):
    d,s = s[0], s[1:]
    parts = [ p if len(p) else None for p in s.split(d) ]
    parts += [None,] * 7
    return parts[:7]


# Tests and actions will be called with arg; that, in turn, may produce a callable test or action for the underlying statemachine
class VerbMap(object):
    def __init__(self, s, d):
        self.name = s
        self.map = d  # {"verb": (callable(arg), "help"),...}


    def lookup(self, key, arg):
        if key not in self.map:
            raise KeyError(f"no '{key}' in {self.name}, run with --more-help for full list")
        return self.map[key][0](arg)


    def help(self):
        keys = sorted([ k for k in self.map.keys() if k ]) + [None,]
        helps = [ (k, self.map[k][1]) for k in keys if self.map[k][1] ]
        help_string = "\n\t".join([ f"{k}:\t{h}" for k,h in helps ])
        return f"{self.name}:\n\t{help_string}"


TESTS = VerbMap("Tests", {
    "T": ((lambda _: sm.trueTest), "always True"),
    "M": (sm.matchTest, "Match a regex pattern"),
    "NLT": ((lambda n: lambda i, t: t.count < int(n)), "input Number Less-Than"),
    "NGT": ((lambda n: lambda i, t: t.count > int(n)), "input Number Greater-Than"),
    "NEQ": ((lambda n: lambda i, t: t.count == int(n)), "input Number EQuals"),
    "L": ((lambda s: s if s else ""), "Literal string"),  # None isn't a thing we'll find in the input lines, test for empty string instead
    None: ((lambda s: s if s else ""), "default test is 'L'"),
})


ACTIONS = VerbMap("Actions", {
    "F": ((lambda p: lambda i, t: p.format(i=i, r=t.result)), "Formatted output; input will be 'i', test result will be 'r'"),
    "I": ((lambda _: sm.inputAction), "return the Input"),
    "L": ((lambda s: s if s else ""), "Literal string"),  # Return empty string instead of None
    None: ((lambda _: None), "default action returns None"),
})
#####


#####
if __name__ == "__main__":
    import os
    import sys
    xit = main(sys.argv, os.environ, sys.stdin)
    sys.exit(xit)
#####
