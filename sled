#!/usr/bin/env python3
# Copyright (c) 2019 Benjamin Holt -- MIT License

"""
Statemachine Line EDitor
or: Sed-Like EDitor

Like `sed` but using consistent statemachine-based rules instead of ad-hoc commands; maybe with some backwards-compatible(ish) conveniences, though (or maybe not)
"""
import argparse
import re

import statemachine as sm
#####


###  Main  ###
def main(args, env, stdin):
    epilog = "Statemachine Line EDitor, like `sed` but built with statemachine rules (v0.1)"
    arg_parser = argparse.ArgumentParser(epilog=epilog)
    # arg_parser.add_argument(
    #     "in_file",
    #     nargs="?",
    #     metavar="FILE",
    #     help="File to parse, defaults to stdin.",
    # )
    arg_parser.add_argument(
        "-s", "--start",
        default="start",
        metavar="STATE",
        help="Start the parser in STATE, defaults to 'start'.",
    )
    arg_parser.add_argument(
        "-r", "--named-rules",
        nargs="+",
        default=[],
        metavar="RULE",
        help="Define named rules to be added to states with -a/--add-rules.",
    )
    arg_parser.add_argument(
        "-a", "--add-rules",
        nargs="+",
        default=[],
        metavar="RULE",
        help="Add rules to the statemachine.",
    )
    arg_parser.add_argument(
        "--more-help",
        action="store_true",
        help="Print help about the available tests and actions.",
    )
    arg_parser.add_argument(
        "--print-args",
        action="store_true",
        # help="Print arguments and compiled rules, then exit.",
        help=argparse.SUPPRESS,
    )
    my_args = arg_parser.parse_args(args[1:])
    named_rules = { n: r for n,*r in parse_rules(my_args.named_rules) }
    rules = parse_rules(my_args.add_rules, aliases=named_rules)
    if my_args.print_args:
        print(f"* Args:\n\t{my_args}\n* Named Rules:\n\t{named_rules}\n* Rules:\n\t{rules}")
        return 0
    if my_args.more_help:
        print(f"{helper(Tests)}\n\n{helper(Actions)}")
        return 0

    parser = sm.StateMachine(my_args.start)
    for r in rules:
        parser.add(*r)

    for line in parser.parse( l.rstrip("\n") for l in stdin ):
        print(line)
#####


###  Rule Parsing  ###
def parse_rules(l, aliases=None):
    rules = []
    for s in l:
        parts = split_rule(s)

        if aliases and len(parts) <= 3:
            # Very short rule may be an alias reference
            parts += [None,] * 3
            if parts[1] in aliases:
                r = [parts[0], *aliases[parts[1]]]
                if parts[2]:
                    # Override the tag if one was specified
                    r[-1] = parts[2]
                rules.append(r)
                continue

        parts += [None,] * 7
        (name, test, t_arg, dst, action, a_arg, tag) = parts[:7]

        if not test:
            test = "_default"
        if test not in Tests.__dict__:
            raise KeyError(f"no '{test}' in Tests, run with --more-help for full list")
        test = Tests.__dict__[test](t_arg)

        if not action:
            action = "_default"
        if action not in Actions.__dict__:
            raise KeyError(f"no '{action}' in Actions, run with --more-help for full list")
        action = Actions.__dict__[action](a_arg)

        rules.append((name, test, dst, action, tag))
    return rules


def split_rule(s):
    d,s = s[0], s[1:]
    parts = [ p if len(p) else None for p in s.split(d) ]
    return parts


class Tests:
    "Tests"
    def T(_):
        "always True"
        return sm.trueTest

    def L(s):
        "Literal string"
        # None isn't a thing we'll find in the input lines, test for empty string instead
        return s if s else ""

    def M(s):
        "Match a regex pattern"
        return sm.matchTest(s)

    def CEQ(n):
        "input Count EQuals"
        n = int(n)
        return lambda i, t: t.count == n

    def CGT(n):
        "input Count Greater-Than"
        n = int(n)
        return lambda i, t: t.count > n

    def CLT(n):
        "input Count Less-Than"
        n = int(n)
        return lambda i, t: t.count < n

    def _default(s):
        "default test is 'L'"
        return Tests.L(s)


class Actions:
    "Actions"
    def F(s):
        "Formatted output; input will be passed as 'i', test result will be 'r'"
        return lambda i, t: s.format(i=i, r=t.result)

    def I(_):
        "return the Input"
        return sm.inputAction

    def L(s):
        "Literal string"
        # Return empty string instead of None
        return s if s else ""

    def _default(s):
        "default action returns None"
        return None


def helper(cls):
    keys = sorted([ k for k in cls.__dict__.keys() if not k.startswith("_") ])
    helps = [ (k, cls.__dict__[k].__doc__) for k in keys if cls.__dict__[k].__doc__ ]
    default_key = "_default"
    if default_key in cls.__dict__ and cls.__dict__[default_key].__doc__:
        helps.append(("None", cls.__dict__[default_key].__doc__))
    help_string = "\n\t".join([ f"{k}:\t{h}" for k,h in helps ])
    return f"{cls.__doc__}:\n\t{help_string}"
#####


#####
if __name__ == "__main__":
    import os
    import sys
    xit = main(sys.argv, os.environ, sys.stdin)
    sys.exit(xit)
#####
