#!/usr/bin/env python3
# Copyright (c) 2019 Benjamin Holt -- MIT License

"""
Statemachine Line EDitor
or: Sed-Like EDitor

Like `sed` but using consistent statemachine-based rules instead of ad-hoc; maybe with some backwards-compatible(ish) conveniences, though
"""
import argparse
import re

import statemachine as sm
#####


###  Main  ###
def main(args, env, stdin):
    epilog = "Statemachine Line EDitor, like `sed` but built with statemachine rules (v0.1)"
    parser = argparse.ArgumentParser(epilog=epilog)
    # parser.add_argument(
    #     "in_file",
    #     nargs="?",
    #     metavar="FILE",
    #     help="File to parse, defaults to stdin.",
    # )
    parser.add_argument(
        "-s", "--start",
        default="start",
        metavar="STATE",
        help="Start the parser in STATE, defaults to 'start'.",
    )
    parser.add_argument(
        "-a", "--add-rules",
        nargs="+",
        # action="append",
        metavar="RULE",
        help="Adds a rule to the statemachine.",
    )
    # parser.add_argument(
    #     "-b", "--buckets",
    #     nargs="+",
    #     type=int,
    #     metavar="X",
    #     help="Buckets to make names for, default is all buckets.",
    # )
    # parser.add_argument(
    #     "-c", "--check-only",
    #     action="store_true",
    #     help="Just check what bucket the user is in, don't generate names.",
    # )
    parser.add_argument(
        "--print-args",
        action="store_true",
        # help="Print arguments and compiled rules, then exit.",
        help=argparse.SUPPRESS,
    )
    my_args = parser.parse_args(args[1:])
    
    if my_args.print_args:
        print(f"* Args:\n\t{my_args}\n")
        return 0
#####


###  Rule Parsing  ###
#####


#####
if __name__ == "__main__":
    import os
    import sys
    xit = main(sys.argv, os.environ, sys.stdin)
    sys.exit(xit)
#####
