#!/usr/bin/env python3
# Copyright (c) 2019 Benjamin Holt -- MIT License

"""
Statemachine Line EDitor
or: Sed-Like EDitor

Like `sed` but using consistent statemachine-based rules instead of ad-hoc; maybe with some backwards-compatible(ish) conveniences, though
"""
import argparse
import re

import statemachine as sm
#####


###  Main  ###
def main(args, env, stdin):
    epilog = "Statemachine Line EDitor, like `sed` but built with statemachine rules (v0.1)"
    arg_parser = argparse.ArgumentParser(epilog=epilog)
    # arg_parser.add_argument(
    #     "in_file",
    #     nargs="?",
    #     metavar="FILE",
    #     help="File to parse, defaults to stdin.",
    # )
    arg_parser.add_argument(
        "-s", "--start",
        default="start",
        metavar="STATE",
        help="Start the parser in STATE, defaults to 'start'.",
    )
    arg_parser.add_argument(
        "-a", "--add-rules",
        nargs="+",
        default=[],
        # action="append",
        metavar="RULE",
        help="Adds a rule to the statemachine.",
    )
    # arg_parser.add_argument(
    #     "-b", "--buckets",
    #     nargs="+",
    #     type=int,
    #     metavar="X",
    #     help="Buckets to make names for, default is all buckets.",
    # )
    # arg_parser.add_argument(
    #     "-c", "--check-only",
    #     action="store_true",
    #     help="Just check what bucket the user is in, don't generate names.",
    # )
    arg_parser.add_argument(
        "--more-help",
        action="store_true",
        help="Print help about the available tests and actions.",
    )
    arg_parser.add_argument(
        "--print-args",
        action="store_true",
        # help="Print arguments and compiled rules, then exit.",
        help=argparse.SUPPRESS,
    )
    my_args = arg_parser.parse_args(args[1:])
    rules = parse_rules(my_args.add_rules)
    if my_args.print_args:
        print(f"* Args:\n\t{my_args}\n* Rules:\n\t{rules}")
        return 0
    if my_args.more_help:
        test_help = "\n\t".join([ f"{k}:\t{h}" for k,h in TESTS.help() ])
        action_help = "\n\t".join([ f"{k}:\t{h}" for k,h in ACTIONS.help() ])
        print(f"Tests:\n\t{test_help}\n\nActions:\n\t{action_help}")
        return 0

    parser = sm.StateMachine(my_args.start)
    for r in rules:
        parser.add(*r)

    for l in parser.parse(stdin):
        print(l, end='')
#####


###  Rule Parsing  ###
def parse_rules(l):
    rules = []
    for s in l:
        (name, test, t_arg, dst, action, a_arg, tag) = split_rule(s)
        test = TESTS.lookup(test, t_arg)
        action = ACTIONS.lookup(action, a_arg)
        rules.append((name, test, dst, action, tag))
    return rules


def split_rule(s):
    d,s = s[0], s[1:]
    parts = [ p if len(p) else None for p in s.split(d) ]
    parts += [None,] * 7
    return parts[:7]




# Tests and actions will be called with arg if callable
# TODO: these can probably be classes
class VerbMap(object):
    def __init__(self, d):
        self.map = d


    def lookup(self, key, arg):
        # This is hard to write a docstring for, which probably means it's a bad idea...
        (v, _) = self.map.get(key, (key, None))
        return v(arg) if callable(v) else v


    def help(self):
        keys = sorted([ k for k in self.map.keys() if k ])
        return [ (k, self.map[k][1]) for k in keys if self.map[k][1] ]


TESTS = VerbMap({
    "True": (lambda _: sm.trueTest, "(T) Always True"),
    "T": (lambda _: sm.trueTest, None),
    "Match": (sm.matchTest, "(M) Match a regex pattern"),
    "M": (sm.matchTest, None),
    None: ("", None),  # None isn't a thing we'll find in the input lines, test for empty string instead
})


ACTIONS = VerbMap({
    "Print": (lambda _: sm.inputAction, "(P) Return the input"),
    "P": (lambda _: sm.inputAction, None),
})
#####


#####
if __name__ == "__main__":
    import os
    import sys
    xit = main(sys.argv, os.environ, sys.stdin)
    sys.exit(xit)
#####
